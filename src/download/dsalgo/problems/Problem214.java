package download.dsalgo.problems;

/**
 * Given a string, find if there is any sub-sequence that repeats itself. A
 * sub-sequence of a string is defined as a sequence of characters generated by
 * deleting some characters in the string without changing the order of the
 * remaining characters.
 * 
 * Input: string
 * 
 * Output:
 * 
 * 0/1 0 -> No 1 -> Yes Example:
 * 
 * abab ------> yes, ab is repeated. So, return 1. abba ------> No, a and b
 * follow different order. So, return 0. NOTE : sub-sequence length should be
 * greater than or equal to 2
 * 
 * @author kaussark
 *
 */
public class Problem214 {

	public static void main(String[] args) {
		String input = "abab";
		System.out.println(new Problem214()._anytwo(input));
	}

	public boolean isPalindrome(String str, int l, int h) {

		// l and h are leftmost and rightmost corners of str
		// Keep comparing characters while they are same
		while (h > l)
			if (str.charAt(l++) != str.charAt(h--))
				return false;

		return true;
	}

	// The main function that checks if repeated
	// subsequence exists in the string
	public boolean _anytwo(String str) {

		// Find length of input string
		int n = str.length();

		// Create an array to store all characters
		// and their frequencies in str[]
		int[] freq = new int[256];

		// Traverse the input string and store frequencies
		// of all characters in freq[] array.
		for (int i = 0; i < n; i++) {
			freq[str.charAt(i)]++;

			// If the character count is more than 2
			// we found a repetition
			if (freq[str.charAt(i)] > 2)
				return true;
		}

		// In-place remove non-repeating characters
		// from the string
		int k = 0;
		for (int i = 0; i < n; i++)
			if (freq[str.charAt(i) ] > 1)
				str.replace(str.charAt(k++), str.charAt(i));
		str.replace(str.charAt(k), '\0');

		// check if the resultant string is palindrome
		if (isPalindrome(str, 0, k - 1)) {

			// special case - if length is odd
			// return true if the middle characer is
			// same as previous one
			if ((k & 1) == 1) {

				// It is checked so that
				// StringIndexOutOfBounds can be avoided
				if (k / 2 >= 1)
					return (str.charAt(k / 2) == str.charAt(k / 2 - 1));
			}

			// return false if string is a palindrome
			return false;
		}

		// return true if string is not a palindrome
		return true;
	}

	public int anytwo(String A) {
		int memo[][] = new int[A.length() + 1][A.length() + 1];

		for (int row = 1; row < memo.length; row++) {
			for (int col = row; col < memo[row].length; col++) {
				if (A.charAt(row - 1) == A.charAt(col - 1) && row != col) {
					memo[row][col] = 1 + memo[row - 1][col - 1];
				} else {
					memo[row][col] = Math.max(memo[row - 1][col],
							memo[row][col - 1]);
				}

			}
		}
		return memo[A.length()][A.length()] >> 1;
	}

}
